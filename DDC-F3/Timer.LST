C51 COMPILER V9.51   TIMER                                                                 04/17/2014 16:56:30 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN Timer.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE Timer.c ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND TABS(3)

line level    source

   1          /*---------------------------------------------------
   2             Timer.c (v1.00)
   3             
   4             Timer functions
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "Timer.h"
  11          #include "communication.h"
  12          #include "Other.h"
  13          #include "voice.h"
  14          #include "AD.h"
  15          #include "delay.h"
  16          
  17          // ------ Public variable declarations -----------------------------
  18          bit fell_alarm_flag = 0;         //µ¹µØ±¨¾¯±êÖ¾
  19          tByte fell_alarm_count = 0;      //µ¹µØ±¨¾¯Ñ­»·´ÎÊý
  20          
  21          bit raised_alarm_flag = 0;    //Ì§Æð±¨¾¯±êÖ¾
  22          tByte raised_alarm_count = 0; //Ì§Æð±¨¾¯Ñ­»·´ÎÊý
  23          
  24          bit stolen_alarm_flag = 0;    //±»µÁ±¨¾¯±êÖ¾
  25          tWord stolen_alarm_count = 0; //±»µÁ±¨¾¯Ñ­»·´ÎÊý
  26          
  27          bit transmit_comm1_flag = 0;     //Ã¿¸ôÒ»¶ÎÊ±¼ä½«ÆäÖÃ1£¬ÔòÔÚmainº¯ÊýÖÐ·¢ÉäÊý¾Ý£¬¾Í²»»áÓ°Ïìtimer0µÄ¼ÆÊ±£¬·¢ÉäÍ
             -êºó½«ÆäÖÃ0.
  28          bit battery_check = 0;           //ÖÃ1Ê±£¬Ö´ÐÐÒ»´ÎµçÁ¿×ª»»£¬Ö´ÐÐÍêºó£¬½«ÆäÖÃ0
  29          bit Host_battery_high_flag = 0;     //ÖÃ1Ê±£¬Ö´ÐÐÒ»´ÎÓïÒôÌáÊ¾£¬±íÊ¾³äµçÒÑÂú
  30          
  31          extern tWord ADC_check_result;      //×÷ÎªAD¼ì²âÖµ
  32          extern bit battery_HV_flag;         //µç³ØµçÎ»µÄ±ê¼Ç£¬1±íÊ¾ÏÖÔÚµç³ØÊÇÂúµÄ£¬0±íÊ¾»¹Ã»Âú¡£
  33          
  34          
  35          // ------ Private variable definitions -----------------------------
  36          tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;  //¶¨Ê±Æ÷0ºÍ1µÄ¶¨Ê±Êý¾Ý
  37          
  38          tWord timer0_count = 0;       //ÓÃÀ´¼ÆÊýtimer0µÄ´ÎÊý£¬Ã»Òç³öÒ»´Î¾Í¼Ó1£¬Ïàµ±ÓÚ¼ÆÊ±
  39          tByte leave_count = 0;           //Ã¿¸ô3s¼Ó1£¬Èç¹ûÖ÷»úÓ¦´ðÕýÈ·£¬Ôò½«ÆäÇåÁã
  40          tByte received_data_buffer[7] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00};   //½ÓÊÕÊý¾Ý»º´æ
  41          bit receive_data_finished_flag = 0;    //½ÓÊÕÕâÒ»´®Êý¾ÝÍê³Éºó£¬´Ë±êÖ¾Î»ÖÃ1
  42          tByte data_count = 0;            //½ÓÊÕÊý¾Ý»º´æµÄÎ»Êý£¬¼´±íÃ÷µÚ¼¸¸ö»º´æÊý¾Ý
  43          tByte one_receive_byte = 0;      //½ÓÊÕÊý¾ÝµÄÒ»¸ö×Ö½Ú£¬½ÓÊÕÍêºó½«Æä¸³Öµ¸øreceived_data_bufferÏà¶ÔÓ¦µÄ×Ö½Ú
  44          tByte one_receive_byte_count = 0;         //one_receive_byteÓÐ8Î»£¬´Ë¼ÆÊý±íÃ÷½ÓÊÕµ½µÚ¼¸Î»£¬Ã¿´Î¼ÆÊýµ½8µÄÊ±ºò±íÃ÷
             -Ò»¸ö×Ö½Ú½ÓÊÕÍê³É¡£
  45          bit receive_wire_flag = 1;    //½ÓÊÕÍ¨ÐÅÏßµÄ±êÖ¾Î»£¬1±íÃ÷¸ßµçÆ½£¬0±íÃ÷µÍµçÆ½£¬Ã¿´Îtimer1Òç³öÊ±£¬ÅÐ¶ÏP1.1Ò»´Î
             -¡£ÒÔ´ËÀ´±íÃ÷ÊÇ·ñÎªÒ»´ÎÕýÈ·µÄÏÂ½µÑØ
  46          tByte receive_HV_count = 0;      //¶¨Ê±Æ÷T1ÔÚÃ»ÓÐÐÅºÅµ½À´µÄÊ±ºò£¬¶Ô¸ßµçÆ½¼ÆÊý£¬Ò»µ©³¬¹ýÄ³¸öÖµ£¬Ôò½«one_receive
             -_byte_countÇå0
  47          tByte receive_LV_count = 0;      //Ã¿´Îtimer1Òç³öÊ±ÅÐ¶Ï½ÓÊÕÏßÈç¹ûÎªLV£¬Ôò¼ÆÊý¼Ó1£¬ÒÔ´ËÀ´±íÃ÷µÍµçÆ½µÄÊ±¼ä
  48          bit battery_stolen_EN = 0;       // ×÷Îª¸½»ú½Óµ½µç³Ø±»µÁÐÅºÅºó£¬±¨¾¯µÄÊ¹ÄÜ
  49          bit wire_broken_EN = 0;          // ËøÏß±»¼ô¶ÏµÄ±¨¾¯Ê¹ÄÜ
  50          
  51          /*------------------------------------------------------------------
C51 COMPILER V9.51   TIMER                                                                 04/17/2014 16:56:30 PAGE 2   

  52             timerT0()
  53             ¶¨Ê±Æ÷0Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
  54          --------------------------------------------------------------------*/
  55          
  56          void timer0() interrupt interrupt_timer_0_overflow
  57             {
  58   1         // ÖØ×°ÔÚ¶¨Ê±Æ÷µÄÊ±¼äÉèÖÃ
  59   1         TH0 = timer0_8H;
  60   1         TL0 = timer0_8L;
  61   1      
  62   1         // ÉèÖÃÒ»¸öÃ¿3sµÄ²Ù×÷
  63   1         if(++timer0_count >= 60)      
  64   1            {
  65   2            // Ã¿¸ö3s×öÒ»´ÎµçÁ¿¼ì²â£¬²¢½øÐÐÏà¹ØµÄµçÁ¿ÌáÊ¾
  66   2            ADC_check_result = GetADCResult(6);
  67   2            
  68   2      
  69   2            
  70   2            // ÅÐ¶Ïµç³ØµçÑ¹£¬Èç¹ûÐ¡ÓÚ3.4VÇÒÔ­ÏÈ±¨¹ý¸ßµçÑ¹Ê±£¬Ôò±¨µçÁ¿²»×ã¡£Èç¹ûµçÑ¹´óÓÚ4.2VÇÒÓëÔ­ÏÈ±¨¹ýµçÁ¿²»×ãÊ±£¬Ô
             -òÌáÊ¾µçÑ¹¹ý¸ß
  71   2            if((battery_HV_flag == 1)&&(ADC_check_result <= 0x333))
  72   2               {
  73   3               // ´ËÎ»ÖÃ0£¬±íÊ¾µçÁ¿¹ýµÍ
  74   3               battery_HV_flag = 0;
  75   3               Battery_low_alarm_speech();      
  76   3               }
  77   2            else if((battery_HV_flag == 0)&&(ADC_check_result >= 0x35a))
  78   2               {
  79   3               // ´ËÎ»ÖÃ1£¬±íÊ¾µçÁ¿¹ý¸ß
  80   3               battery_HV_flag = 1;
  81   3               Battery_high_alarm_speech();
  82   3               }  
  83   2      
  84   2            // ½«¼ÆÊýÇå0
  85   2            timer0_count = 0;
  86   2      //    battery_stolen_EN = 1;
  87   2            }
  88   1      
  89   1         // Ö÷»ú±»µÁ±¨¾¯
  90   1         if(stolen_alarm_flag == 1)    
  91   1            {
  92   2            // Ö÷»ú±»µÁ±¨¾¯´ÎÊý£¬Ã¿±¨Ò»´Î¼Ó1£¬Èç¹û´óÓÚ2´Î£¬Ôò¼ÌÐø¼Ó1£¬µ½Ò»¶¨Ê±¼äºó£¬½«flagºÍcountÇå0.ÒÔ´ËÀ´±£Ö¤¸½»úÃ
             -¿´Î±¨¾¯ºó£¬ÔÚ¶ÌÊ±¼äÄÚ
  93   2            // ÔÙ´ÎÊÕµ½±¨¾¯ÐÅºÅ£¬¾Í²»»á±¨¾¯ÁË¡£
  94   2            if(++stolen_alarm_count < 3)
  95   2               {        
  96   3               // ÓïÒôÌáÊ¾£¬Âí´ïÕñ¶¯
  97   3               Alarm_stolen_speech();     
  98   3               Moto_Vibration();          
  99   3               }
 100   2            else
 101   2               {
 102   3               if(stolen_alarm_count >= 1200)
 103   3                  {
 104   4                  stolen_alarm_count = 0;
 105   4                  stolen_alarm_flag = 0;
 106   4                  }
 107   3               }
 108   2            }  
 109   1      
 110   1         // Ì§ÆðÐÅºÅ±¨¾¯£¬Ã¿´Î±¨ÍêºóÇå0£¬Èç¹ûÔÙ´Î½Óµ½Ôò¼ÌÐø±¨¡£Ò»°ãÀ´Ëµ£¬Ö÷»úÃ¿´ÎÌ§ÆðÖ»·¢4±é¡£
 111   1         if(raised_alarm_flag == 1) 
C51 COMPILER V9.51   TIMER                                                                 04/17/2014 16:56:30 PAGE 3   

 112   1            {
 113   2            Alarm_raised_speech();     
 114   2            Moto_Vibration();         
 115   2            raised_alarm_flag = 0;
 116   2            }
 117   1      
 118   1         // µ¹µØÐÅºÅ±¨¾¯£¬Ã¿´Î±¨ÍêºóÇå0£¬Èç¹ûÔÙ´Î½Óµ½Ôò¼ÌÐø±¨¡£Ò»°ãÀ´Ëµ£¬Ö÷»úÃ¿´Îµ¹µØÖ»·¢4±é¡£
 119   1         if(fell_alarm_flag == 1)
 120   1            {
 121   2            Alarm_fell_speech();      
 122   2            Moto_Vibration();         
 123   2            fell_alarm_flag=0;
 124   2            }
 125   1      
 126   1         // Ö÷»úµçÁ¿³äÂúÌáÊ¾
 127   1         if(Host_battery_high_flag == 1)
 128   1            {
 129   2            Host_battery_high_alarm_speech();      
 130   2            Host_battery_high_flag = 0;
 131   2            }
 132   1            
 133   1         if(battery_stolen_EN == 1)
 134   1            {
 135   2            battery_stolen_speech();
 136   2            battery_stolen_EN = 0;
 137   2            }
 138   1         
 139   1         if(wire_broken_EN == 1)
 140   1            {
 141   2            wire_broken_speech();
 142   2            wire_broken_EN = 0;
 143   2            }
 144   1         }
 145          
 146          /*------------------------------------------------------------------
 147             timerT1()
 148             ¶¨Ê±Æ÷1Ã¿´ÎÒç³öºóÖ´ÐÐµÄ²Ù×÷
 149          --------------------------------------------------------------------*/
 150             
 151          void timerT1() interrupt interrupt_timer_1_overflow         
 152             {
 153   1         // ÖØ×°ÔÚ¶¨Ê±Æ÷1µÄÉèÖÃ
 154   1         TH1 = timer1_8H;           
 155   1         TL1 = timer1_8L;
 156   1      
 157   1         // ÅÐ¶Ï½ÓÊÕÏßÊÇ·ñÎª0£¬Èç¹ûÊÇ0£¬Ôò±íÊ¾¿ÉÄÜÓÐÐÅºÅ¹ýÀ´¡£
 158   1         if(receive_wire == 0)               
 159   1            {
 160   2            // Èç¹û½ÓÊÕÏßÊÇ0£¬Ôò½«´Ë±êÖ¾Î»ÖÃ0£¬±íÊ¾´ËÏßÎª0¹ý¡£
 161   2            receive_wire_flag=0;
 162   2            
 163   2            // ½ÓÊÕµ½µÍµçÆ½µÄÊ±¼ä¼ÆÊý£¬´óÓÚ8ms¾ÍÖØÐÂ¼ÆÊý
 164   2            if(++receive_LV_count==120)      
 165   2               {
 166   3               receive_LV_count=0;
 167   3               }
 168   2            }
 169   1         else
 170   1         {
 171   2            if(receive_wire_flag==0)//ËµÃ÷ÓÐÒ»¸öµÍµçÆ½
 172   2            {
 173   3               receive_wire_flag=1;
C51 COMPILER V9.51   TIMER                                                                 04/17/2014 16:56:30 PAGE 4   

 174   3      //       one_receive_byte<<=1;
 175   3      
 176   3               if((receive_LV_count>35)&&(receive_LV_count<=80))//µÍµçÆ½³ÖÐøµÄÊ±¼äÐ¡ÓÚ3ms£¬ÔòÎª0
 177   3               {
 178   4                  one_receive_byte<<=1;
 179   4                  one_receive_byte &= 0xfe;
 180   4                  one_receive_byte_count++;
 181   4                  receive_HV_count=0;
 182   4               }
 183   3               if(receive_LV_count>80)//µÍµçÆ½³ÖÐøµÄÊ±¼ä´óÓÚ4.5ms£¬ÔòÎª1
 184   3               {
 185   4                  one_receive_byte<<=1;
 186   4                  one_receive_byte |= 0x01;
 187   4                  one_receive_byte_count++;
 188   4                  receive_HV_count=0;
 189   4               }
 190   3               else
 191   3               {
 192   4                  receive_HV_count++;  
 193   4               }
 194   3      
 195   3               receive_LV_count=0;
 196   3            }
 197   2            else
 198   2            {
 199   3               receive_HV_count++;
 200   3               if(receive_HV_count>=60)
 201   3               {
 202   4                  one_receive_byte_count=0;
 203   4                  receive_wire_flag=1;
 204   4                  data_count=0;
 205   4               }     
 206   3            }
 207   2         }
 208   1      
 209   1         if(one_receive_byte_count==8)//ËµÃ÷Ò»¸ö×Ö½ÚµÄÊý¾ÝÒÑ¾­½ÓÊÜÍêÈ«
 210   1         {
 211   2            one_receive_byte_count=0;
 212   2            received_data_buffer[data_count]=one_receive_byte;
 213   2            if(data_count==0&&received_data_buffer[0]==CmdHead)
 214   2               {
 215   3               data_count=1;
 216   3               }
 217   2            else if(data_count==1&&received_data_buffer[1]==MyAddress)
 218   2               {
 219   3               data_count=2;
 220   3               }
 221   2            else if(data_count==2)
 222   2            {
 223   3               receive_data_finished_flag=1;
 224   3               data_count=0;
 225   3            }
 226   2            else 
 227   2            {
 228   3               data_count=0;
 229   3            }
 230   2         }
 231   1      
 232   1         if(receive_data_finished_flag==1)   //ËµÃ÷½ÓÊÕµ½ÁËÊý¾Ý£¬¿ªÊ¼´¦Àí
 233   1            {
 234   2            receive_data_finished_flag=0; //Çå½ÓÊÕ±êÖ¾
 235   2            switch(received_data_buffer[2])//½âÎöÖ¸Áî
C51 COMPILER V9.51   TIMER                                                                 04/17/2014 16:56:30 PAGE 5   

 236   2               {
 237   3               case ComMode_1://½ÓÊÕµ½µÄÊÇÖ÷»ú·¢ËÍ¹ýÀ´µÄ±àÂë1µÄÐÅºÅ£¬ËµÃ÷Ö÷»úÔÚ3MÄÚ£¬ÊÇÕý³£µÄ
 238   3                  {  
 239   4                  Moto_Vibration();
 240   4                  ComMode_1_Data();
 241   4                  }
 242   3               break;
 243   3               
 244   3               case ComMode_2:
 245   3                  {
 246   4                  battery_stolen_EN = 1;
 247   4                  Moto_Vibration();          
 248   4                  }
 249   3               break;
 250   3               
 251   3               case ComMode_3:
 252   3                  {
 253   4                  stolen_alarm_flag = 1;
 254   4                  Moto_Vibration();         
 255   4      
 256   4                  raised_alarm_count=0;
 257   4                  raised_alarm_flag=0;
 258   4                  fell_alarm_count=0;
 259   4                  fell_alarm_flag=0;
 260   4                  }
 261   3               break;
 262   3            
 263   3               case ComMode_4:
 264   3                  {
 265   4                  raised_alarm_flag=1;
 266   4      
 267   4                  stolen_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 268   4                  stolen_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 269   4                  fell_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 270   4                  fell_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 271   4                  }
 272   3               break;
 273   3      
 274   3               case ComMode_5://Áô×÷µ¹µØÐÅºÅÊ¹ÓÃ
 275   3                  {
 276   4                  fell_alarm_flag=1;   //µ¹µØ±¨¾¯
 277   4      
 278   4                  stolen_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 279   4                  stolen_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 280   4                  raised_alarm_count=0;//Çå±¨¾¯¼ÆÊýÆ÷
 281   4                  raised_alarm_flag=0;//Çå±¨¾¯±êÖ¾
 282   4                  }
 283   3               break;
 284   3      
 285   3               case ComMode_6:
 286   3                  {
 287   4                  wire_broken_EN = 1;
 288   4                  Moto_Vibration();
 289   4                  }
 290   3               break;
 291   3               }
 292   2            }
 293   1      }
 294          
 295          /*--------------------------------------------------
 296             InitTimer()
 297             
C51 COMPILER V9.51   TIMER                                                                 04/17/2014 16:56:30 PAGE 6   

 298             ³õÊ¼»¯¶¨Ê±Æ÷T0ºÍT1
 299          ---------------------------------------------------*/
 300          
 301          void InitTimer(const tByte Tick_ms_T0, Tick_us_T1)
 302             {
 303   1         tLong Inc_T0, Inc_T1;
 304   1         tWord timer0_16, timer1_16;
 305   1         
 306   1         //¼ÆËãTimer0µÄ¼Ä´æÆ÷Öµ
 307   1         Inc_T0 = (tLong)Tick_ms_T0 * (OSC_FREQ/1000) / (tLong)OSC_PER_INST;
 308   1         timer0_16 = (tWord) (65536UL - Inc_T0);
 309   1         timer0_8H = (tByte) (timer0_16 / 256);
 310   1         timer0_8L = (tByte) (timer0_16 % 256);
 311   1         
 312   1         //¼ÆËãTimer1µÄ¼Ä´æÆ÷Öµ
 313   1         Inc_T1 = (tLong)Tick_us_T1 * (OSC_FREQ/1000000) / (tLong)OSC_PER_INST;
 314   1         timer1_16 = (tWord) (65536UL - Inc_T1);
 315   1         timer1_8H = (tByte) (timer1_16 / 256);
 316   1         timer1_8L = (tByte) (timer1_16 % 256);
 317   1         
 318   1         TMOD = 0x11;
 319   1         TH0 = timer0_8H;
 320   1         TL0 = timer0_8L;
 321   1         TH1 = timer1_8H;
 322   1         TL1 = timer1_8L;
 323   1      
 324   1         ET0 = 1;
 325   1         TR0 = 1;
 326   1         ET1 = 1;
 327   1         TR1 = 1;
 328   1         PT1 = 1;       
 329   1         EA = 1;
 330   1         }
 331          
 332          /*---------------------------------------------------------------------
 333             sEos_Go_To_Sleep()
 334             ½«MCU½øÈëÐÝÃß×´Ì¬
 335          ----------------------------------------------------------------------*/
 336          void sEOS_Go_To_Sleep(void)
 337             {
 338   1         PCON |= 0x01;    // Enter idle mode (generic 8051 version)
 339   1         }
 340          
 341          /*---------------------------------------------------
 342             end of file
 343          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    650    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     10    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
